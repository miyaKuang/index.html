<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Interactive Graph Builder</title>
<link rel="stylesheet" href="https://unpkg.com/@picocss/pico@2.0.6/css/pico.min.css">
<script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
<style>
  :root { --gap: 0.8rem; }
  body { padding-block: 1rem 2rem; }
  #plot { width: 100%; height: 640px; }
  .grid { display: grid; grid-template-columns: 320px 1fr; gap: var(--gap); }
  .row { display: grid; gap: var(--gap); grid-template-columns: repeat(2,1fr); }
  .chips { display: flex; flex-wrap: wrap; gap: .5rem; }
  .chip { padding: .25rem .6rem; border: 1px solid var(--pico-muted-border-color); border-radius: 999px; cursor: pointer; }
  .chip.active { background: var(--pico-primary-background); color: white; border-color: var(--pico-primary); }
  table input { width: 100%; }
  #dataTable td, #dataTable th { white-space: nowrap; }
  #legendSwatches span{display:inline-block;width:12px;height:12px;border-radius:2px;margin-right:.4rem;vertical-align:middle}
  footer { margin-top: 2rem; opacity: .7; }
</style>
</head>
<body>
<main class="container">
  <h2>Interactive Graph Builder</h2>

  <div class="grid">
    <!-- Controls -->
    <section>
      <article>
        <label>Chart type</label>
        <select id="chartType">
          <option>Bar (incidence)</option>
          <option>Dot (forest/CI)</option>
        </select>

        <label class="mt-2">Title</label>
        <input id="titleInput" value="Average value by subgroup, grouped by category" />

        <div class="row">
          <div>
            <label># Big groups</label>
            <input id="nBig" type="number" min="1" max="10" value="3"/>
          </div>
          <div>
            <label>Forest: y-tick step</label>
            <input id="ytick" type="number" step="0.05" value="0.5"/>
          </div>
        </div>

        <details open>
          <summary>Big group names</summary>
          <div id="bigGroupInputs" class="row"></div>
        </details>

        <details open>
          <summary>Subgroups (click to toggle)</summary>
          <div id="subgroupChips" class="chips"></div>
        </details>

        <details>
          <summary>Appearance</summary>
          <label>Y label</label>
          <input id="yLabel" value="Y value (units)"/>
          <div class="row">
            <label><input type="checkbox" id="showGrid" checked/> Show grid</label>
            <label><input type="checkbox" id="refLine" checked/> Forest: show y=1 reference</label>
          </div>
          <div class="row">
            <label><input type="checkbox" id="showCI" checked/> Show confidence intervals</label>
            <label>
              Subgroup gap (bars)
              <input id="subgap" type="number" step="0.01" min="0" max="0.9" value="0.25"/>
            </label>
          </div>
          <div class="row">
            <label><input type="checkbox" id="blackCI" checked/> CI in black</label>
            <label>
              Bracket position
              <select id="bracketPos">
                <option>Top of groups</option>
                <option>Right of groups</option>
              </select>
            </label>
          </div>
        </details>

        <label>Chat tweaks</label>
        <input id="chatBox" placeholder="e.g., title=My Plot | type=dot | brackets=right | ref=false | ytick=0.25 | subgap=0.35" />
        <small>Press Enter to apply. Keys: <code>title</code>, <code>type</code>=bar|dot, <code>brackets</code>=top|right, <code>ref</code>=true|false, <code>ytick</code>, <code>subgap</code></small>

        <hr/>
        <button id="randomize" class="secondary">Randomize Demo Data</button>
        <button id="draw">Draw</button>
        <button id="export">Export PNG</button>

        <p id="legendSwatches" class="mt-2"></p>
      </article>
    </section>

    <!-- Data -->
    <section>
      <article>
        <h5>Data</h5>
        <p class="mt-0">Edit cells directly. Columns for both chart types use a single metric column named <code>Y</code>.
          <br><strong>Bar:</strong> <code>BigGroup, Subgroup, Y, LowerCI (optional), UpperCI (optional)</code>
          <br><strong>Dot/Forest:</strong> <code>BigGroup, Subgroup, Y, LowerCI (optional), UpperCI (optional), PValue (optional)</code>
        </p>
        <div style="overflow:auto;max-height:520px">
          <table id="dataTable" class="striped"></table>
        </div>
      </article>
      <article>
        <div id="plot"></div>
      </article>
    </section>
  </div>

  <footer>
    <small>Single-file demo. Edit data, toggle CI, set subgroup gaps, and export PNG.</small>
  </footer>
</main>

<script>
/* ---------- Defaults & palette ---------- */
const DEFAULT_SECOND = [
  "Apple","Banana","Cherry","Grape","Orange",
  "Carrot","Broccoli","Spinach","Tomato","Potato"
];
const PALETTE = {
  "Apple":"#1f77b4","Banana":"#ff7f0e","Cherry":"#2ca02c","Grape":"#d62728","Orange":"#9467bd",
  "Carrot":"#8c564b","Broccoli":"#e377c2","Spinach":"#17becf","Tomato":"#bcbd22","Potato":"#7f7f7f"
};
let state = {
  chartType: "Bar (incidence)",
  title: document.querySelector("#titleInput").value,
  nBig: +document.querySelector("#nBig").value,
  bigGroups: ["Category A","Category B","Category C"].slice(0, +document.querySelector("#nBig").value),
  subgroups: [...DEFAULT_SECOND.slice(0,6)],
  showGrid: true,
  refLine: true,
  ytick: 0.5,
  blackCI: true,
  bracketPos: "Top of groups",
  showCI: true,
  subgap: 0.25,
  data: []
};

/* ---------- UI builders ---------- */
function buildBigGroupInputs(){
  const wrap = document.querySelector("#bigGroupInputs");
  wrap.innerHTML = "";
  for(let i=0;i<state.nBig;i++){
    const inp = document.createElement("input");
    inp.value = state.bigGroups[i] || `Group ${i+1}`;
    inp.oninput = () => { state.bigGroups[i] = inp.value; };
    wrap.appendChild(inp);
  }
}

function chipsFromList(list){
  const box = document.querySelector("#subgroupChips");
  box.innerHTML = "";
  list.forEach(label=>{
    const chip = document.createElement("span");
    chip.className = "chip" + (state.subgroups.includes(label) ? " active":"");
    chip.textContent = label;
    chip.onclick = ()=>{
      if(state.subgroups.includes(label)){
        state.subgroups = state.subgroups.filter(x=>x!==label);
        chip.classList.remove("active");
      } else {
        state.subgroups.push(label);
        chip.classList.add("active");
      }
      makeRandomData(); renderTable(); draw();
    };
    box.appendChild(chip);
  });
}

function buildSubgroupChips(){
  chipsFromList(DEFAULT_SECOND);
}

function buildLegend(){
  const el = document.querySelector("#legendSwatches");
  el.innerHTML = "<strong>Subgroup colors:</strong> ";
  state.subgroups.forEach(s=>{
    const sw = `<span style="background:${PALETTE[s]||"#4d4d4d"}"></span>${s}&nbsp;&nbsp;`;
    el.insertAdjacentHTML("beforeend", sw);
  });
}

/* ---------- Data generation & table ---------- */
function rand(min, max){ return Math.random()*(max-min)+min; }

function makeRandomData(){
  const type = document.querySelector("#chartType").value;
  const rows = [];
  state.bigGroups.forEach(bg=>{
    state.subgroups.forEach(sg=>{
      const Y = +(rand(0.2, 2.0)).toFixed(3);
      const lo = Math.random()<0.7 ? +(Math.max(0.01, Y - rand(0.05, 0.4))).toFixed(3) : "";
      const hi = Math.random()<0.7 ? +(Y + rand(0.05, 0.4)).toFixed(3) : "";
      const p  = Math.random()<0.4 ? +(rand(0, 0.2)).toFixed(4) : "";
      if(type==="Bar (incidence)"){
        rows.push({BigGroup:bg, Subgroup:sg, Y, LowerCI:lo, UpperCI:hi});
      } else {
        rows.push({BigGroup:bg, Subgroup:sg, Y, LowerCI:lo, UpperCI:hi, PValue:p});
      }
    });
  });
  state.data = rows;
}

function uniqueSubgroupsFromData(){
  const set = new Set(state.data.map(d=>d.Subgroup).filter(Boolean));
  return [...set];
}

function renderTable(){
  const tbl = document.querySelector("#dataTable");
  tbl.innerHTML = "";
  if(!state.data.length){ return; }
  const keys = Object.keys(state.data[0]);
  const thead = document.createElement("thead");
  const hrow = document.createElement("tr");
  keys.forEach(k=>{ const th=document.createElement("th"); th.textContent=k; hrow.appendChild(th);});
  thead.appendChild(hrow);
  tbl.appendChild(thead);
  const tbody = document.createElement("tbody");
  state.data.forEach((row,ridx)=>{
    const tr = document.createElement("tr");
    keys.forEach(k=>{
      const td = document.createElement("td");
      const inp = document.createElement("input");
      inp.value = row[k];
      inp.onchange = ()=>{
        state.data[ridx][k] = (k==="BigGroup"||k==="Subgroup") ? inp.value : (inp.value===""? "": +inp.value);
        // Auto-rebuild chips if Subgroup column changed
        if(k==="Subgroup"){
          const latest = uniqueSubgroupsFromData();
          const was = new Set(state.subgroups);
          state.subgroups = latest.filter(s => was.has(s));
          if(state.subgroups.length===0) state.subgroups = latest;
          chipsFromList(latest);
          buildLegend();
        }
        draw();
      };
      td.appendChild(inp);
      tr.appendChild(td);
    });
    tbody.appendChild(tr);
  });
  tbl.appendChild(tbody);
}

/* ---------- Drawing ---------- */
function draw(){
  const container = document.querySelector("#plot");
  const type = document.querySelector("#chartType").value;
  const blackCI = document.querySelector("#blackCI").checked;
  const showGrid = document.querySelector("#showGrid").checked;
  const showCI = document.querySelector("#showCI").checked;
  const subgap = Math.min(0.9, Math.max(0, +document.querySelector("#subgap").value || 0.25));

  if(type==="Bar (incidence)"){
    const orderBG = [...state.bigGroups];
    const orderSG = [...state.subgroups];

    const x = [], y = [], errUp=[], errDown=[], colors=[], ticktext=[];
    orderBG.forEach(bg=>{
      orderSG.forEach(sg=>{
        const row = state.data.find(d=>d.BigGroup===bg && d.Subgroup===sg);
        if(!row) return;
        const cat = `${bg} • ${sg}`;
        x.push(cat);
        y.push(+row.Y);
        const up = row.UpperCI==="" || row.UpperCI==null ? 0 : (+row.UpperCI - +row.Y);
        const down = row.LowerCI==="" || row.LowerCI==null ? 0 : (+row.Y - +row.LowerCI);
        errUp.push(up); errDown.push(down);
        colors.push(PALETTE[sg]||"#4d4d4d");
        ticktext.push(sg); // only subgroup names on axis
      });
    });

    const traces = [{
      type:"bar",
      x, y,
      marker:{color:colors},
      error_y:{
        type:"data", array:errUp, arrayminus:errDown,
        visible: showCI,
        color: blackCI ? "#000" : undefined,
        thickness:1.5, width:4
      },
      hovertemplate:"%{x}<br>Y=%{y:.3f}<extra></extra>"
    }];

    // brackets (thicker & higher)
    const shapes=[]; const annotations=[];
    if(document.querySelector("#bracketPos").value==="Top of groups"){
      let idx = 0;
      orderBG.forEach(bg=>{
        const n = orderSG.filter(sg => x.includes(`${bg} • ${sg}`)).length;
        if(n===0) return;
        const xStart = x[idx], xEnd = x[idx+n-1];
        shapes.push(
          { type:"line", xref:"x", yref:"paper", x0:xStart, x1:xEnd, y0:1.14, y1:1.14, line:{color:"#000",width:3}},
          { type:"line", xref:"x", yref:"paper", x0:xStart, x1:xStart, y0:1.14, y1:1.08, line:{color:"#000",width:3}},
          { type:"line", xref:"x", yref:"paper", x0:xEnd, x1:xEnd, y0:1.14, y1:1.08, line:{color:"#000",width:3}}
        );
        annotations.push({xref:"x", yref:"paper", x:x[Math.floor(idx + (n-1)/2)], y:1.18, text:bg, showarrow:false, font:{size:12}});
        idx += n;
      });
    }

    const layout = {
      title: document.querySelector("#titleInput").value,
      bargap: subgap,
      bargroupgap: 0.05,
      xaxis: {
        title: "", ticks:"outside", automargin:true,
        tickmode: "array", tickvals: x, ticktext: ticktext
      },
      yaxis: {
        title: document.querySelector("#yLabel").value,
        gridcolor: showGrid? "rgba(0,0,0,.15)" : "rgba(0,0,0,0)"
      },
      margin: { t: 110, r: 10, l: 70, b: 150 },
      shapes, annotations
    };
    Plotly.newPlot(container, traces, layout, {displaylogo:false, responsive:true});

  } else {
    const orderBG = [...state.bigGroups];
    const orderSG = [...state.subgroups];
    const traces = [];

    // flat list for custom ticks
    const xcats = [];
    orderBG.forEach(bg=>{
      orderSG.forEach(sg=>{
        const row = state.data.find(d=>d.BigGroup===bg && d.Subgroup===sg);
        if(row) xcats.push({cat:`${bg} • ${sg}`, sg});
      });
    });

    orderSG.forEach(sg=>{
      const xs=[], ys=[], up=[], down=[];
      orderBG.forEach(bg=>{
        const row = state.data.find(d=>d.BigGroup===bg && d.Subgroup===sg);
        if(!row) return;
        xs.push(`${bg} • ${sg}`);
        ys.push(+row.Y);
        const u = row.UpperCI==="" || row.UpperCI==null ? 0 : (+row.UpperCI - +row.Y);
        const d = row.LowerCI==="" || row.LowerCI==null ? 0 : (+row.Y - +row.LowerCI);
        up.push(u); down.push(d);
      });
      if(xs.length){
        traces.push({
          type:"scatter", mode:"markers",
          x: xs, y: ys, name: sg,
          marker:{ color: PALETTE[sg]||"#4d4d4d", size:8 },
          error_y: { type:"data", array: up, arrayminus: down,
                     visible: document.querySelector("#showCI").checked,
                     color: document.querySelector("#blackCI").checked ? "#000" : (PALETTE[sg]||"#4d4d4d") }
        });
      }
    });

    const shapes=[]; const annotations=[];
    if(document.querySelector("#refLine").checked){
      shapes.push({type:"line", x0:0, x1:1, y0:1, y1:1, xref:"paper", yref:"y", line:{color:"red", width:2, dash:"dash"}});
    }
    if(document.querySelector("#bracketPos").value==="Top of groups"){
      let idx = 0;
      orderBG.forEach(bg=>{
        const n = orderSG.filter(sg => xcats.find(c=>c.cat===`${bg} • ${sg}`)).length;
        if(n===0) return;
        const xStart = xcats[idx].cat, xEnd = xcats[idx+n-1].cat;
        shapes.push(
          { type:"line", xref:"x", yref:"paper", x0:xStart, x1:xEnd, y0:1.14, y1:1.14, line:{color:"#000",width:3}},
          { type:"line", xref:"x", yref:"paper", x0:xStart, x1:xStart, y0:1.14, y1:1.08, line:{color:"#000",width:3}},
          { type:"line", xref:"x", yref:"paper", x0:xEnd, x1:xEnd, y0:1.14, y1:1.08, line:{color:"#000",width:3}}
        );
        annotations.push({xref:"x", yref:"paper", x:xcats[Math.floor(idx + (n-1)/2)].cat, y:1.18, text:bg, showarrow:false, font:{size:12}});
        idx += n;
      });
    }

    const ytick = +document.querySelector("#ytick").value || 0.5;
    const layout = {
      title: document.querySelector("#titleInput").value,
      xaxis:{
        title:"", automargin:true,
        tickmode:"array",
        tickvals: xcats.map(c=>c.cat),
        ticktext: xcats.map(c=>c.sg)
      },
      yaxis:{ title: document.querySelector("#yLabel").value,
              dtick: ytick,
              gridcolor: document.querySelector("#showGrid").checked? "rgba(0,0,0,.15)":"rgba(0,0,0,0)" },
      margin:{ t: 110, r: 20, l: 70, b: 150 },
      shapes, annotations, legend:{orientation:"h", y:-0.15}
    };
    Plotly.newPlot(container, traces, layout, {displaylogo:false, responsive:true});
  }
}

/* ---------- Events ---------- */
document.querySelector("#chartType").onchange = ()=>{
  makeRandomData(); renderTable(); draw();
};
document.querySelector("#titleInput").oninput = ()=> draw();
document.querySelector("#nBig").oninput = (e)=>{
  const n = Math.max(1, Math.min(10, +e.target.value||1));
  state.nBig = n;
  while(state.bigGroups.length < n) state.bigGroups.push(`Group ${state.bigGroups.length+1}`);
  state.bigGroups = state.bigGroups.slice(0,n);
  buildBigGroupInputs(); makeRandomData(); renderTable(); draw();
};
document.querySelector("#bigGroupInputs").addEventListener("input", ()=> draw());
document.querySelector("#yLabel").oninput = ()=> draw();
document.querySelector("#showGrid").onchange = ()=> draw();
document.querySelector("#refLine").onchange = ()=> draw();
document.querySelector("#ytick").oninput = ()=> draw();
document.querySelector("#blackCI").onchange = ()=> draw();
document.querySelector("#bracketPos").onchange = ()=> draw();
document.querySelector("#showCI").onchange = ()=> draw();
document.querySelector("#subgap").oninput = ()=> draw();

document.querySelector("#randomize").onclick = ()=>{
  makeRandomData(); renderTable(); draw();
};
document.querySelector("#draw").onclick = ()=> draw();
document.querySelector("#export").onclick = ()=>{
  Plotly.toImage(document.querySelector("#plot"), {format:"png", width:1200, height:720})
    .then(dataUrl=>{
      const a = document.createElement("a");
      a.href = dataUrl; a.download = "chart.png"; a.click();
    });
};

/* Chat tweaks */
document.querySelector("#chatBox").addEventListener("keydown", (e)=>{
  if(e.key==="Enter"){
    const s=e.target.value.trim(); e.target.value="";
    if(!s) return;
    s.split("|").map(x=>x.trim()).forEach(kv=>{
      const [k,v]=kv.split("=").map(z=>z?.trim());
      if(!k) return;
      if(k==="title") document.querySelector("#titleInput").value = v || "";
      if(k==="type"){ document.querySelector("#chartType").value = (v==="dot"?"Dot (forest/CI)":"Bar (incidence)"); }
      if(k==="brackets"){ document.querySelector("#bracketPos").value = (v==="right"?"Right of groups":"Top of groups"); }
      if(k==="ref"){ document.querySelector("#refLine").checked = !(v==="false"||v==="0"||v==="no"); }
      if(k==="ytick"){ document.querySelector("#ytick").value = v; }
      if(k==="subgap"){ document.querySelector("#subgap").value = v; }
    });
    draw();
  }
});

/* ---------- Boot ---------- */
function boot(){
  buildBigGroupInputs();
  buildSubgroupChips();
  buildLegend();
  makeRandomData();
  renderTable();
  draw();
}
boot();
</script>
</body>
</html>
